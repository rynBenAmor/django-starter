<!-- widgets/key_value_widget.html -->
 <!-- ? Note: script and style can be injected elsewhere to avoid repetition if multiple widgets-->


<div class="key-value-widget" id="{{ widget.attrs.id }}-container">
  <table class="key-value-table">
    <thead>
      <tr>
        <th>Key</th>
        <th>Value</th>
        <th style="color: transparent; font-size: 0;"> actions </th>
      </tr>
    </thead>
    <tbody>
      {% for key, value in widget.value %}
      <tr>
        <td>
          <input type="text" 
                 name="{{ widget.name }}_key" 
                 value="{{ key }}" 
                 placeholder="Key" 
                 class="key-input">
        </td>
        <td>
          <input type="text" 
                 name="{{ widget.name }}_value" 
                 value="{{ value }}" 
                 placeholder="Value" 
                 class="value-input">
        </td>
        <td>
          <button title="remove" type="button" class="remove-row-btn">
            <i class="fa fa-times"></i>
          </button>
        </td>
      </tr>
      {% endfor %}
    </tbody>
  </table>
  <button type="button" class="add-row-btn">
    <i class="fa fa-plus"></i> Add Row
  </button>
</div>

<style>
  /* Compact widget styling */
  .key-value-widget {
    max-width: 440px;
    font-size: 13px;
  }
  
  .key-value-table {
    width: 100%;
    border-collapse: collapse;
    margin-bottom: 8px;
    background: white;
    border: 1px solid #ddd;
  }
  
  .key-value-table th,
  .key-value-table td {
    padding: 6px 8px;
    border: 1px solid #ddd;
    vertical-align: middle;
  }
  
  .key-value-table th {
    background: #f5f5f5;
    font-weight: 600;
    text-align: left;
  }
  
  .key-value-table input[type="text"] {
    width: 100%;
    padding: 4px 6px;
    border: 1px solid #ddd;
    border-radius: 3px;
    box-sizing: border-box;
    font-size: 13px;
  }
  
  .key-value-table input[type="text"]:focus {
    outline: none;
    border-color: #79aec8;
  }
  
  .remove-row-btn {
    background: none;
    border: none;
    color: #999;
    cursor: pointer;
    padding: 2px 4px;
    font-size: 12px;
  }
  
  .remove-row-btn:hover {
    color: #ff4444;
  }
  
  .add-row-btn {
    background: #79aec8;
    color: white;
    border: none;
    border-radius: 3px;
    padding: 6px 10px;
    font-size: 12px;
    cursor: pointer;
  }
  
  .add-row-btn:hover {
    background: #609ab6;
  }
  
  /* Make it even more compact for very small screens */
  @media (max-width: 440px) {
    .key-value-table th,
    .key-value-table td {
      padding: 4px 6px;
    }
    
    .key-value-table input[type="text"] {
      padding: 3px 4px;
    }
    
    .add-row-btn {
      padding: 4px 8px;
    }
  }
</style>


<script>
  (function () {

    function initKeyValueWidgets() {
        document.querySelectorAll('.key-value-widget').forEach(function (container) {

            const table = container.querySelector('.key-value-table');
            const tbody = table.querySelector('tbody');
            const addButton = container.querySelector('.add-row-btn');

            function addRow(key = '', value = '') {
                const lastRow = tbody.lastElementChild;
                if (lastRow) {
                    const lastKey = lastRow.querySelector('.key-input').value.trim();
                    const lastValue = lastRow.querySelector('.value-input').value.trim();
                    if (!lastKey && !lastValue) {
                        lastRow.querySelector('.key-input').focus();
                        return;
                    }
                }

                // ! important : django widget view expects keys = data.getlist(f'{name}_key') and values = data.getlist(f'{name}_value')
                //container.id == id_main-${index}-specifications-container, we must clean it first to match the {{widget.name}}

                const keyName = `${container.id}_key`.replace('-container', '').replace('id_', '').trim()

                const valueName = `${container.id}_value`.replace('-container', '').replace('id_', '').trim()

                const row = document.createElement('tr');
                row.innerHTML = `
            <td>
              <input type="text" 
                    name="${keyName}" 
                    value="${key}" 
                    placeholder="Key" 
                    class="key-input">
            </td>
            <td>
              <input type="text" 
                    name="${valueName}" 
                    value="${value}" 
                    placeholder="Value" 
                    class="value-input">
            </td>
            <td>
              <button type="button" class="remove-row-btn">
                <i class="fa fa-times"></i>
              </button>
            </td>
          `;

                tbody.appendChild(row);
                row.querySelector('.key-input').focus();
            }

            function removeRow(row) {
                row.remove();
            }

            table.addEventListener('click', function (e) {
                if (e.target.closest('.remove-row-btn')) {
                    removeRow(e.target.closest('tr'));
                }
            });

            addButton.addEventListener('click', function () {
                addRow();
            });

            if (tbody.querySelectorAll('tr').length === 0) {
                addRow();
            }
        });
    }

    
    document.addEventListener('DOMContentLoaded',
        /*
        * // ? ISSUE: For client-side-rendered widgets (e.g. added via "Add another" in Django admin),
        * // the inputs do NOT include {{ widget.name }} because that only exists server-side.
        
        * // * GOOD NEWS: The admin panel *does* assign a unique {{ widget.attrs.id }} to each new inline,
        * // and we can reliably use that in our JavaScript to reconstruct the expected input names.

        * // ? PROBLEM: We have no reliable hook into the exact moment when Django injects these new inlines.
        * // Their lifecycle is async and undocumented — sometimes they appear after DOMContentLoaded,
        * // sometimes not at all if JS hasn’t kicked in yet.

        * // * SOLUTION: Use polling (setInterval) to repeatedly scan and initialize widgets as they appear.
        * // Yes, it's inefficient, but it **HECKIN' WORKS**, and that’s all that matters for now.

        * // TODO (future): Replace with a MutationObserver or a Django-specific hook for better performance.

        */

        
        container = document.querySelector('.key-value-widget')); // make sure i'm not polling nothing

        if (container) {
           
            let loopCounter = 0;
            setInterval(() => {
                console.log("KV widget initiation loop counter n°", loopCounter)
                initKeyValueWidgets();
                loopCounter++;
            }, 1000);

        }


})();
</script>